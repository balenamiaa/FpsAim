<AimAssistModule.cs>
using System.Diagnostics;
using Microsoft.ML.OnnxRuntime;

namespace AimAssist;

public enum AimAssistTarget
{
    Head,
    Torso
}

public enum Executer
{
    Cpu,
    Cuda,
    TensorRT
}

public readonly record struct AimAssistConfiguration
{
    public required InferenceEngine Engine { get; init; }
    public required ITargetPredictor TargetPredictor { get; init; }
    public required ISmoothingFunction SmoothingFunction { get; init; }
    public required IAimAssistCondition ActivationCondition { get; init; }
    public required AimAssistTarget Target { get; init; }
    public required float ConfidenceThreshold { get; init; }
    public required int CaptureWidth { get; init; }
    public required int CaptureHeight { get; init; }
    public required float XCorrectionMultiplier { get; init; }
    public required float YCorrectionMultiplier { get; init; }

    public static SessionOptions GetSessionOptions(Executer executer)
    {
        var options = new SessionOptions { GraphOptimizationLevel = GraphOptimizationLevel.ORT_ENABLE_ALL };
        return executer switch
        {
            Executer.Cpu => options,
            Executer.Cuda => Apply(o => o.AppendExecutionProvider_CUDA()),
            Executer.TensorRT => Apply(o => o.AppendExecutionProvider_Tensorrt()),
            _ => throw new ArgumentOutOfRangeException()
        };

        SessionOptions Apply(Action<SessionOptions> f)
        {
            f(options);
            return options;
        }
    }
}

public class AimAssistModule(AimAssistConfiguration configuration)
{
    public void Run()
    {
        using var screenCapturer = new ScreenCapturer(0, configuration.CaptureWidth, configuration.CaptureHeight);
        using var mouseMover = new MouseMover();

        var classToTarget = configuration.Target switch
        {
            AimAssistTarget.Head => 0,
            AimAssistTarget.Torso => 1,
            _ => throw new ArgumentOutOfRangeException()
        };

        var screenWidth = screenCapturer.ScreenWidth;
        var screenHeight = screenCapturer.ScreenHeight;
        var screenCenterX = screenWidth / 2;
        var screenCenterY = screenHeight / 2;

        Warmup(screenCapturer);

        Console.WriteLine("Aim assist is running. Press Ctrl+C to exit.");

        var frames = 0;
        var totalTimeMs = 0L;
        var stopwatch = Stopwatch.StartNew();
        while (true)
        {
            configuration.ActivationCondition.Update();
            var frame = screenCapturer.CaptureFrame();
            if (frame is null) continue;

            configuration.Engine.Infer(frame.Value, configuration.CaptureWidth, configuration.CaptureHeight,
                configuration.ConfidenceThreshold);

            var detections = NonMaximumSuppression.Applied(configuration.Engine.GetBestDetections(), 0.5f);

            var detectionResult = GetClosestToCenter(detections.Where(d => d.ClassId == classToTarget));

            if (detectionResult is { } detection)
            {
                var targetX = (detection.XMin + detection.XMax) / 2.0f;
                var targetY = (detection.YMin + detection.YMax) / 2.0f;
                var (predictedX, predictedY) =
                    configuration.TargetPredictor.Predict(targetX, targetY,
                        stopwatch.Elapsed.TotalSeconds); // We predict regardless to build the model.

                if (configuration.ActivationCondition.ShouldAimAssist())
                {
                    var (x, y) =
                        detection.OffsetAbsoluteFromCenter(predictedX, predictedY, screenCenterX, screenCenterY);
                    var distance = detection.GetDistanceUnits(x, y, screenCenterX, screenCenterY);

                    var dx = configuration.XCorrectionMultiplier * (x - screenCenterX);
                    var dy = configuration.YCorrectionMultiplier * (y - screenCenterY);

                    var smoothingFactor = configuration.SmoothingFunction.Calculate(distance);
                    var dxSmoothed = (int)Math.Ceiling(dx * smoothingFactor);
                    var dySmoothed = (int)Math.Ceiling(dy * smoothingFactor);
                    mouseMover.MoveRelative(dxSmoothed, dySmoothed);
                }
            }

            var elapsedMs = stopwatch.ElapsedMilliseconds;
            totalTimeMs += elapsedMs;
            frames++;

            if (frames % 1000 == 0)
            {
                Console.WriteLine($"Total time: {totalTimeMs / (float)frames} ms");
                frames = 0;
                totalTimeMs = 0;
            }

            stopwatch.Restart();
        }
    }


    private static DetectionResult? GetClosestToCenter(
        IEnumerable<DetectionResult> detections)
    {
        DetectionResult? best = null;
        var bestDistance = float.MaxValue;

        foreach (var detection in detections)
        {
            var centerX = (detection.XMin + detection.XMax) / 2.0f;
            var centerY = (detection.YMin + detection.YMax) / 2.0f;
            var distance = detection.GetDistanceUnits(centerX, centerY,
                detection.Width / 2,
                detection.Height / 2
            );

            switch (best)
            {
                case not null when distance < bestDistance:
                    best = detection;
                    bestDistance = distance;
                    break;
                case null:
                    best = detection;
                    break;
            }
        }

        return best;
    }


    private void Warmup(ScreenCapturer screenCapturer, int warmupFrames = 10)
    {
        for (var i = 0; i < warmupFrames; i++)
        {
            var frame = screenCapturer.CaptureFrame();
            if (frame is null) continue;

            configuration.Engine.Infer(frame.Value, configuration.CaptureWidth, configuration.CaptureHeight, 0.1f);
        }
    }
}
</AimAssistModule.cs>
<ClickOnceActivationCondition.cs>
namespace AimAssist;

internal class ClickOnceActivationCondition(ClickOnceActivationCondition.ClickMouseButton button) : IAimAssistCondition
{
    private State _state = new(false);

    public enum ClickMouseButton
    {
        Mouse4,
        Mouse5
    }

    private bool IsDown => button switch
    {
        ClickMouseButton.Mouse4 => MouseMover.IsMouse4Down(),
        ClickMouseButton.Mouse5 => MouseMover.IsMouse5Down(),
        _ => throw new ArgumentOutOfRangeException()
    };

    public bool ShouldAimAssist()
    {
        var result = IsDown && !_state.WasPreviouslyDown;
        return result;
    }

    public void Update()
    {
        _state = new State(IsDown);
    }


    private readonly record struct State(bool WasPreviouslyDown);
}
</ClickOnceActivationCondition.cs>
<IAimAssistCondition.cs>
namespace AimAssist;

public interface IAimAssistCondition
{
    public bool ShouldAimAssist();
    void Update();
}
</IAimAssistCondition.cs>
<ImageExtractor.cs>
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;

namespace AimAssist;

public class ImageExtractor
{
    private readonly string _outputDirectory;

    public ImageExtractor(string outputDirectory)
    {
        _outputDirectory = outputDirectory;

        if (!Directory.Exists(outputDirectory)) Directory.CreateDirectory(outputDirectory);
    }

    public void BeginLoop()
    {
        var width = 640;
        var height = 640;
        var screenCapturer = new ScreenCapturer(0, width, height);
        var lastTime = new Stopwatch();
        lastTime.Start();
        while (true)
            unsafe
            {
                if (!IsButtonHeldMouse5()) continue;
                if (lastTime.ElapsedMilliseconds <= 500) continue;

                var frame = screenCapturer.CaptureFrame();
                if (frame is null) continue;

                var path = Path.Combine(_outputDirectory, $"{Guid.NewGuid()}.png");
                using var bitmap = new Bitmap(640, 640, PixelFormat.Format24bppRgb);
                var bmpData = bitmap.LockBits(new Rectangle(0, 0, 640, 640), ImageLockMode.WriteOnly,
                    bitmap.PixelFormat);
                var pBmp = (byte*)bmpData.Scan0;
                Parallel.For(0, height, y =>
                {
                    for (var x = 0; x < width; x++)
                    {
                        var pixelR = frame.Value.Span[y * width + x];
                        var pixelG = frame.Value.Span[y * width + x + width * height];
                        var pixelB = frame.Value.Span[y * width + x + 2 * width * height];
                        pBmp[y * bmpData.Stride + x * 3] = (byte)(pixelB * 255);
                        pBmp[y * bmpData.Stride + x * 3 + 1] = (byte)(pixelG * 255);
                        pBmp[y * bmpData.Stride + x * 3 + 2] = (byte)(pixelR * 255);
                    }
                });

                bitmap.UnlockBits(bmpData);
                bitmap.Save(path, ImageFormat.Png);
                lastTime.Restart();
            }
    }

    private static bool IsButtonHeldMouse5()
    {
        return (MouseMover.GetAsyncKeyState(0x06) & 0x8000) != 0;
    }
}
</ImageExtractor.cs>
<InferenceEngine.cs>
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Microsoft.ML.OnnxRuntime;

namespace AimAssist;

public class InferenceEngine : IDisposable
{
    protected const int MaxDetections = 150;


    protected readonly DetectionResult[] DetectionsBuffer = new DetectionResult[MaxDetections];
    protected readonly int InputHeight;
    protected readonly int InputWidth;
    protected readonly InferenceSession Session;

    protected InferenceEngine(string modelPath, SessionOptions sessionOptions)
    {
        Session = new InferenceSession(modelPath, sessionOptions);
        var inputMeta = Session.InputMetadata;
        Debug.Assert(inputMeta.Count == 1);

        var firstInput = inputMeta.First();
        InputWidth = firstInput.Value.Dimensions[3];
        InputHeight = firstInput.Value.Dimensions[2];
    }


    void IDisposable.Dispose()
    {
        Session.Dispose();
    }

    public virtual void Infer(Memory<float> input, int width, int height,
        float confidenceThreshold)
    {
        Debug.Assert(width == InputWidth && height == InputHeight,
            "Input dimensions do not match the model input dimensions.");
        Array.Clear(DetectionsBuffer, 0, MaxDetections);
    }

    public IEnumerable<DetectionResult> GetBestDetections()
    {
        var bestScores = new Dictionary<int, float>();
        var bestResults = new Dictionary<int, DetectionResult>();

        foreach (var detection in DetectionsBuffer)
        {
            var classId = (int)detection.ClassId;
            if (!(detection.Confidence > bestScores.GetValueOrDefault(classId, 0))) continue;

            bestScores[classId] = detection.Confidence;
            bestResults[classId] = detection;
        }

        return bestResults.Values;
    }
}

public readonly record struct DetectionResult
{
    public required long ClassId { get; init; }
    public required float Confidence { get; init; }
    public required float XMin { get; init; }
    public required float YMin { get; init; }
    public required float XMax { get; init; }
    public required float YMax { get; init; }
    public required float Width { get; init; }
    public required float Height { get; init; }

    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public float GetDistanceUnits(float x1, float y1, float x2, float y2)
    {
        var width = XMax - XMin;
        var height = YMax - YMin;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var dxNorm = dx / width;
        var dyNorm = dy / height;

        return MathF.Sqrt(dxNorm * dxNorm + dyNorm * dyNorm);
    }

    public (float, float) OffsetRelativeFromCenter(float xNorm, float yNorm, float centerX, float centerY)
    {
        var top = centerY - Height / 2;
        var left = centerX - Width / 2;

        return (left + xNorm * Width, top + yNorm * Height);
    }

    public (float, float) OffsetAbsoluteFromCenter(float x, float y, float centerX, float centerY)
    {
        var top = centerY - Height / 2;
        var left = centerX - Width / 2;

        return (left + x, top + y);
    }
}
</InferenceEngine.cs>
<Interception.cs>
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace AimAssist;

[SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
public static partial class Interception
{
    public const int InterceptionMaxKeyboard = 10;
    public const int InterceptionMaxMouse = 10;
    public const int InterceptionMaxDevice = InterceptionMaxKeyboard + InterceptionMaxMouse;

    public const ushort InterceptionKeyDown = 0x00;
    public const ushort InterceptionKeyUp = 0x01;
    public const ushort InterceptionKeyE0 = 0x02;
    public const ushort InterceptionKeyE1 = 0x04;
    public const ushort InterceptionKeyTermsrvSetLed = 0x08;
    public const ushort InterceptionKeyTermsrvShadow = 0x10;
    public const ushort InterceptionKeyTermsrvVkpacket = 0x20;

    public const ushort InterceptionFilterKeyNone = 0x0000;
    public const ushort InterceptionFilterKeyAll = 0xFFFF;
    public const ushort InterceptionFilterKeyDown = InterceptionKeyUp;
    public const ushort InterceptionFilterKeyUp = InterceptionKeyUp << 1;
    public const ushort InterceptionFilterKeyE0 = InterceptionKeyE0 << 1;
    public const ushort InterceptionFilterKeyE1 = InterceptionKeyE1 << 1;
    public const ushort InterceptionFilterKeyTermsrvSetLed = InterceptionKeyTermsrvSetLed << 1;
    public const ushort InterceptionFilterKeyTermsrvShadow = InterceptionKeyTermsrvShadow << 1;
    public const ushort InterceptionFilterKeyTermsrvVkpacket = InterceptionKeyTermsrvVkpacket << 1;

    public const ushort InterceptionMouseLeftButtonDown = 0x001;
    public const ushort InterceptionMouseLeftButtonUp = 0x002;
    public const ushort InterceptionMouseRightButtonDown = 0x004;
    public const ushort InterceptionMouseRightButtonUp = 0x008;
    public const ushort InterceptionMouseMiddleButtonDown = 0x010;
    public const ushort InterceptionMouseMiddleButtonUp = 0x020;

    public const ushort InterceptionMouseButton1Down = InterceptionMouseLeftButtonDown;
    public const ushort InterceptionMouseButton1Up = InterceptionMouseLeftButtonUp;
    public const ushort InterceptionMouseButton2Down = InterceptionMouseRightButtonDown;
    public const ushort InterceptionMouseButton2Up = InterceptionMouseRightButtonUp;
    public const ushort InterceptionMouseButton3Down = InterceptionMouseMiddleButtonDown;
    public const ushort InterceptionMouseButton3Up = InterceptionMouseMiddleButtonUp;

    public const ushort InterceptionMouseButton4Down = 0x040;
    public const ushort InterceptionMouseButton4Up = 0x080;
    public const ushort InterceptionMouseButton5Down = 0x100;
    public const ushort InterceptionMouseButton5Up = 0x200;

    public const ushort InterceptionMouseWheel = 0x400;
    public const ushort InterceptionMouseHwheel = 0x800;

    public const ushort InterceptionFilterMouseNone = 0x0000;
    public const ushort InterceptionFilterMouseAll = 0xFFFF;

    public const ushort InterceptionFilterMouseLeftButtonDown = InterceptionMouseLeftButtonDown;
    public const ushort InterceptionFilterMouseLeftButtonUp = InterceptionMouseLeftButtonUp;
    public const ushort InterceptionFilterMouseRightButtonDown = InterceptionMouseRightButtonDown;
    public const ushort InterceptionFilterMouseRightButtonUp = InterceptionMouseRightButtonUp;

    public const ushort InterceptionFilterMouseMiddleButtonDown =
        InterceptionMouseMiddleButtonDown;

    public const ushort InterceptionFilterMouseMiddleButtonUp = InterceptionMouseMiddleButtonUp;

    public const ushort InterceptionFilterMouseButton1Down = InterceptionMouseButton1Down;
    public const ushort InterceptionFilterMouseButton1Up = InterceptionMouseButton1Up;
    public const ushort InterceptionFilterMouseButton2Down = InterceptionMouseButton2Down;
    public const ushort InterceptionFilterMouseButton2Up = InterceptionMouseButton2Up;
    public const ushort InterceptionFilterMouseButton3Down = InterceptionMouseButton3Down;
    public const ushort InterceptionFilterMouseButton3Up = InterceptionMouseButton3Up;

    public const ushort InterceptionFilterMouseButton4Down = InterceptionMouseButton4Down;
    public const ushort InterceptionFilterMouseButton4Up = InterceptionMouseButton4Up;
    public const ushort InterceptionFilterMouseButton5Down = InterceptionMouseButton5Down;
    public const ushort InterceptionFilterMouseButton5Up = InterceptionMouseButton5Up;

    public const ushort InterceptionFilterMouseWheel = InterceptionMouseWheel;
    public const ushort InterceptionFilterMouseHwheel = InterceptionMouseHwheel;

    public const ushort InterceptionFilterMouseMove = 0x1000;

    public const ushort InterceptionMouseMoveRelative = 0x000;
    public const ushort InterceptionMouseMoveAbsolute = 0x001;
    public const ushort InterceptionMouseVirtualDesktop = 0x002;
    public const ushort InterceptionMouseAttributesChanged = 0x004;
    public const ushort InterceptionMouseMoveNocoalesce = 0x008;
    public const ushort InterceptionMouseTermsrvSrcShadow = 0x100;

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial IntPtr interception_create_context();

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial void interception_destroy_context(IntPtr context);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_get_precedence(IntPtr context, int device);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial void interception_set_precedence(IntPtr context, int device, int precedence);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial ushort interception_get_filter(IntPtr context, int device);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial void interception_set_filter(IntPtr context, IntPtr predicate, ushort filter);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_wait(IntPtr context);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_wait_with_timeout(IntPtr context, ulong milliseconds);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_send(IntPtr context, int device,
        in InterceptionMouseStroke stroke, uint nstroke);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_receive(IntPtr context, int device,
        out InterceptionMouseStroke stroke, uint nstroke);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial uint interception_get_hardware_id(IntPtr context, int device, IntPtr hardwareIdBuffer,
        uint bufferSize);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_is_invalid(int device);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_is_keyboard(int device);

    [LibraryImport("interception")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    public static partial int interception_is_mouse(int device);

    [StructLayout(LayoutKind.Sequential)]
    public struct InterceptionMouseStroke
    {
        public ushort state;
        public ushort flags;
        public short rolling;
        public int x;
        public int y;
        public uint information;
    }
}
</Interception.cs>
<ISmoothingFunction.cs>
namespace AimAssist;

public interface ISmoothingFunction
{
    float Calculate(float distance);
}
</ISmoothingFunction.cs>
<ITargetPredictor.cs>
namespace AimAssist;

public interface ITargetPredictor
{
    (float X, float Y) Predict(float targetX, float targetY, double dt);
}
</ITargetPredictor.cs>
<KalmanFilterPredictor.cs>
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Double;

namespace AimAssist;

public class KalmanFilterPredictor : ITargetPredictor
{
    private readonly Matrix<double> _a; // State transition matrix
    private readonly Matrix<double> _h; // Measurement matrix
    private readonly Matrix<double> _q; // Process noise covariance
    private readonly Matrix<double> _r; // Measurement noise covariance
    private KalmanFilterState _state;

    public KalmanFilterPredictor(float assumedFps = 60.0f, float processNoiseFactor = 0.1f,
        float measurementNoiseFactor = 1.0f)
    {
        var c = 1.0 / assumedFps;

        // Model - Assuming constant velocity
        _a = Matrix.Build.DenseOfArray(new[,]
        {
            { 1, 0, c, 0 },
            { 0, 1, 0, c },
            { 0, 0, 1, 0 },
            { 0, 0, 0, 1 }
        });

        // Measurement matrix (we're only observing position)
        _h = Matrix.Build.DenseOfArray(new double[,]
        {
            { 1, 0, 0, 0 },
            { 0, 1, 0, 0 }
        });

        // Process noise covariance (adjust as needed)
        _q = Matrix.Build.DiagonalIdentity(4) * processNoiseFactor;

        // Measurement noise covariance (adjust based on measurement accuracy)
        _r = Matrix.Build.DiagonalIdentity(2) * measurementNoiseFactor;

        _state = new KalmanFilterState
        {
            X = Vector.Build.Dense(4), // Initial state (assuming target at rest)
            P = Matrix.Build.DiagonalIdentity(4) * 100.0 // Large initial uncertainty
        };
    }

    public (float X, float Y) Predict(float targetX, float targetY, double dt)
    {
        // 1. Prediction
        var predictedX = _a * _state.X;
        var predictedP = _a * _state.P * _a.Transpose() + _q;

        // 2. Measurement Update
        var z = Vector.Build.Dense(new[] { targetX, (double)targetY });
        var y = z - _h * predictedX;
        var s = _h * predictedP * _h.Transpose() + _r;
        var k = predictedP * _h.Transpose() * s.Inverse();
        _state.X = predictedX + k * y;
        _state.P = (Matrix.Build.DiagonalIdentity(4) - k * _h) * predictedP;

        return ((float)_state.X[0], (float)_state.X[1]);
    }

    private record struct KalmanFilterState(Vector<double> X, Matrix<double> P);
}
</KalmanFilterPredictor.cs>
<KeyNotDownActivationCondition.cs>
namespace AimAssist;

// MouseButton param ignored because so far we only support LButton
internal class KeyNotDownActivationCondition(KeyNotDownActivationCondition.MouseButton _)
    : IAimAssistCondition
{
    public enum MouseButton
    {
        LButton
    }

    private State _state;

    public bool ShouldAimAssist()
    {
        return !_state.IsKeyDown[(int)MouseButton.LButton];
    }

    public void Update()
    {
        _state = MouseMover.IsLeftMouseButtonDown()
            ? new State { IsKeyDown = [true] }
            : new State { IsKeyDown = [false] };
    }


    private record struct State
    {
        public bool[] IsKeyDown { get; init; }
    }
}
</KeyNotDownActivationCondition.cs>
<LinearPredictor.cs>
namespace AimAssist;

public class LinearPredictor : ITargetPredictor
{
    private LinearPredictorState? State { get; set; }

    public (float X, float Y) Predict(float targetX, float targetY, double dt)
    {
        switch (State)
        {
            case null:
                State = new LinearPredictorState(targetX, targetY);
                return (targetX, targetY);
            case { } state:
                var deltaX = targetX - state.PreviousX;
                var deltaY = targetY - state.PreviousY;
                var predictedX = targetX + (float)(deltaX * dt);
                var predictedY = targetY + (float)(deltaY * dt);
                State = new LinearPredictorState(targetX, targetY);
                return (predictedX, predictedY);
        }
    }


    private record struct LinearPredictorState(float PreviousX, float PreviousY);
}
</LinearPredictor.cs>
<LogarithmicSmoothing.cs>
namespace AimAssist;

public class LogarithmicSmoothing(float baseSmoothing) : ISmoothingFunction
{
    public float Calculate(float distance)
    {
        return baseSmoothing / (1.0f + MathF.Log(distance + 1));
    }
}
</LogarithmicSmoothing.cs>
<MouseMover.cs>
using System.Runtime.InteropServices;

namespace AimAssist;

public sealed partial class MouseMover : IDisposable
{
    private readonly IntPtr _context = Interception.interception_create_context();
    private readonly int _device = GetMouseDevice();

    public void Dispose()
    {
        Interception.interception_destroy_context(_context);
    }

    private static int GetMouseDevice()
    {
        var device = 12;
        while (true)
        {
            if (device >= 30) throw new Exception("No mouse device found");

            if (Interception.interception_is_mouse(device) != 0) return device;

            device++;
        }
    }

    public void MoveRelative(int dx, int dy)
    {
        var stroke = new Interception.InterceptionMouseStroke
        {
            state = 0,
            flags = Interception.InterceptionMouseMoveRelative,
            rolling = 0,
            x = dx,
            y = dy,
            information = 0
        };

        var result = Interception.interception_send(_context, _device, stroke, 1);

        if (result != 1) throw new Exception("Mouse movement error");
    }

    public static bool IsMouse5Down()
    {
        return GetAsyncKeyState(0x06) != 0;
    }

    public static bool IsMouse4Down()
    {
        return GetAsyncKeyState(0x05) != 0;
    }

    public static bool IsLeftMouseButtonDown()
    {
        return GetAsyncKeyState(0x01) != 0;
    }

    [LibraryImport("user32.dll")]
    public static partial short GetAsyncKeyState(int vKey);
}
</MouseMover.cs>
<NonMaximumSuppression.cs>
using System.Collections.Immutable;

namespace AimAssist;

public static class NonMaximumSuppression
{
    public static IEnumerable<DetectionResult> Applied(IEnumerable<DetectionResult> detections, float iouThreshold)
    {
        var detectionsArray = detections.ToImmutableArray();
        var isSuppressed = new bool[detectionsArray.Length];

        for (var i = 0; i < detectionsArray.Length; i++)
        {
            if (isSuppressed[i]) continue;

            for (var j = i + 1; j < detectionsArray.Length; j++)
                if (Iou(detectionsArray[i], detectionsArray[j]) > iouThreshold)
                    isSuppressed[j] = true;
        }


        return detectionsArray.Where((_, i) => !isSuppressed[i]);
    }

    private static float Iou(DetectionResult box1, DetectionResult box2)
    {
        var x1 = Math.Max(box1.XMin, box2.XMin);
        var y1 = Math.Max(box1.YMin, box2.YMin);
        var x2 = Math.Min(box1.XMax, box2.XMax);
        var y2 = Math.Min(box1.YMax, box2.YMax);

        var intersection = Math.Max(x2 - x1, 0) * Math.Max(y2 - y1, 0);
        var box1Area = (box1.XMax - box1.XMin) * (box1.YMax - box1.YMin);
        var box2Area = (box2.XMax - box2.XMin) * (box2.YMax - box2.YMin);

        return intersection / (box1Area + box2Area - intersection);
    }
}
</NonMaximumSuppression.cs>
<NullPredictor.cs>
namespace AimAssist;

public class NullPredictor : ITargetPredictor
{
    public (float X, float Y) Predict(float targetX, float targetY, double _)
    {
        return (targetX, targetY);
    }
}
</NullPredictor.cs>
<NullSmoothing.cs>
namespace AimAssist;

public class NullSmoothing : ISmoothingFunction
{
    public float Calculate(float _)
    {
        return 1.0f;
    }
}
</NullSmoothing.cs>
<Program.cs>
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace AimAssist;

public static class Program
{
    [SuppressMessage("ReSharper", "FunctionNeverReturns")]
    private static void BenchmarkScreenCapturer()
    {
        using var screenCapturer = new ScreenCapturer(0, 320, 320);


        while (true)
        {
            var totalTimeMilliseconds = 0.0;
            for (var i = 0; i < 100; i++)
            {
                var stopwatch = Stopwatch.StartNew();
                _ = screenCapturer.CaptureFrame();
                stopwatch.Stop();
                totalTimeMilliseconds += stopwatch.Elapsed.TotalMilliseconds;
            }

            Console.WriteLine($"Average time: {totalTimeMilliseconds / 100} ms");
        }
    }

    private static AimAssistConfiguration FlickConfiguration => new()
    {
        ConfidenceThreshold = 0.5f,
        Target = AimAssistTarget.Head,
        CaptureWidth = 320,
        CaptureHeight = 320,
        Engine = new YoloV8Engine("v8-nn.onnx", AimAssistConfiguration.GetSessionOptions(Executer.TensorRT)),
        TargetPredictor = new LinearPredictor(),
        SmoothingFunction = new NullSmoothing(),
        XCorrectionMultiplier = 22.0f * (640.0f / 1280.0f),
        YCorrectionMultiplier = 22.0f / 1.2f * (640.0f / 1280.0f),
        ActivationCondition = new ClickOnceActivationCondition(ClickOnceActivationCondition.ClickMouseButton.Mouse5)
    };

    private static AimAssistConfiguration TrackingConfiguration => new()
    {
        ConfidenceThreshold = 0.5f,
        Target = AimAssistTarget.Head,
        CaptureWidth = 320,
        CaptureHeight = 320,
        Engine = new YoloV8Engine("v8-nn.onnx", AimAssistConfiguration.GetSessionOptions(Executer.TensorRT)),
        TargetPredictor = new LinearPredictor(),
        SmoothingFunction = new SigmoidSmoothing(1.1f, 0.8f, 1.6f, 3f),
        XCorrectionMultiplier = 22.0f * (640.0f / 1280.0f),
        YCorrectionMultiplier = 22.0f / 1.2f * (640.0f / 1280.0f),
        ActivationCondition = new KeyNotDownActivationCondition(KeyNotDownActivationCondition.MouseButton.LButton)
    };

    private static void RunAimAssist()
    {
        var aimAssistModule = new AimAssistModule(TrackingConfiguration);
        aimAssistModule.Run();
    }

    public static void Main(string[] args)
    {
        RunAimAssist();
    }
}
</Program.cs>
<ScreenCapturer.cs>
using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using Vortice.D3DCompiler;
using Vortice.Direct3D;
using Vortice.Direct3D11;
using Vortice.DXGI;
using Vortice.Mathematics;
using ResultCode = Vortice.DXGI.ResultCode;

namespace FpsAim
{
    public class ScreenCapturer : IDisposable
    {
        private static readonly FeatureLevel[] FeatureLevels =
        {
            FeatureLevel.Level_11_1,
            FeatureLevel.Level_11_0,
        };

        private readonly IDXGIAdapter1 _adapter;
        private readonly int _captureHeight;
        private readonly int _captureWidth;
        private readonly ID3D11DeviceContext _context;
        private readonly ID3D11Device _d3D11Device;
        private IDXGIOutputDuplication _duplication;
        private readonly IDXGIFactory1 _factory;
        private readonly IDXGIOutput1 _output;
        private readonly ID3D11ComputeShader _computeShader;
        private readonly ID3D11Buffer _outputBuffer;

        [SuppressMessage("ReSharper", "NotAccessedField.Local")]
        private ID3D11Buffer _captureRegionBuffer;

        private readonly ID3D11UnorderedAccessView _outputUav;
        private readonly ID3D11Buffer _stagingBuffer;

        private const string ShaderCode = @"
cbuffer CaptureRegion : register(b0)
{
    int2 offset;
    int2 captureSize;
};

RWStructuredBuffer<float> output : register(u0);

Texture2D<float4> inputTexture : register(t0);

[numthreads(8, 8, 1)]
void CSMain(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if (dispatchThreadID.x >= captureSize.x || dispatchThreadID.y >= captureSize.y)
    {
        return;
    }

    int2 texCoord = dispatchThreadID.xy + offset;
    float4 color = inputTexture[texCoord];

    int width = captureSize.x;
    int height = captureSize.y;

    int bufferIndexR = dispatchThreadID.y * width + dispatchThreadID.x;
    int bufferIndexG = height * width + bufferIndexR;
    int bufferIndexB = 2 * height * width + bufferIndexR;

    output[bufferIndexR] = color.r;
    output[bufferIndexG] = color.g;
    output[bufferIndexB] = color.b;
}
        ";

        private readonly ThreadLocal<float[]> _backingArray;

        public int MonitorIndex { get; }

        public int ScreenWidth { get; private set; }
        public int ScreenHeight { get; private set; }

        public ScreenCapturer(int monitorIndex, int captureWidth, int captureHeight)
        {
            MonitorIndex = monitorIndex;
            _captureWidth = captureWidth;
            _captureHeight = captureHeight;
            _backingArray = new ThreadLocal<float[]>(() => new float[_captureWidth * _captureHeight * 3]);

            Initialize(out _factory, out _adapter, out _d3D11Device, out _context, out _output,
                out _duplication, out _computeShader, out _outputBuffer, out _outputUav, out _captureRegionBuffer,
                out _stagingBuffer);
        }

        public void Dispose()
        {
            GC.SuppressFinalize(this);
            _outputUav.Dispose();
            _stagingBuffer.Dispose();
            _duplication.Dispose();
            _context.Dispose();
            _d3D11Device.Dispose();
            _output.Dispose();
            _adapter.Dispose();
            _factory.Dispose();
        }

        private void Initialize(out IDXGIFactory1 factory, out IDXGIAdapter1 adapter,
            out ID3D11Device device, out ID3D11DeviceContext context, out IDXGIOutput1 output,
            out IDXGIOutputDuplication duplication, out ID3D11ComputeShader computeShader,
            out ID3D11Buffer outputBuffer, out ID3D11UnorderedAccessView outputUav,
            out ID3D11Buffer captureRegionBuffer, out ID3D11Buffer stagingBuffer)
        {
            factory = DXGI.CreateDXGIFactory1<IDXGIFactory1>();
            factory.EnumAdapters1(0, out adapter);
            adapter.EnumOutputs(MonitorIndex, out var outputGeneric);
            output = outputGeneric.QueryInterface<IDXGIOutput1>();
            D3D11.D3D11CreateDevice(adapter, DriverType.Unknown, DeviceCreationFlags.None, FeatureLevels, out device,
                out context);
            duplication = output.DuplicateOutput(device);

            var desc = output.Description;
            ScreenWidth = desc.DesktopCoordinates.Right - desc.DesktopCoordinates.Left;
            ScreenHeight = desc.DesktopCoordinates.Bottom - desc.DesktopCoordinates.Top;

            computeShader = device.CreateComputeShader(Compiler
                .Compile(ShaderCode, "CSMain", "RgbTensorConvertor", "cs_5_0",
                    ShaderFlags.OptimizationLevel3)
                .Span);

            context.CSSetShader(_computeShader, []);

            outputBuffer = device.CreateBuffer(
                new BufferDescription(
                    _captureWidth * _captureHeight * 3 * sizeof(float),
                    BindFlags.UnorderedAccess | BindFlags.ShaderResource
                )
            );

            outputUav = device.CreateUnorderedAccessView(outputBuffer,
                new UnorderedAccessViewDescription
                {
                    Format = Format.R32_Float,
                    ViewDimension = UnorderedAccessViewDimension.Buffer,
                    Buffer = new BufferUnorderedAccessView
                    {
                        FirstElement = 0,
                        NumElements = _captureWidth * _captureHeight * 3
                    }
                }
            );

            stagingBuffer = device.CreateBuffer(new BufferDescription(
                _captureWidth * _captureHeight * 3 * sizeof(float),
                BindFlags.None,
                ResourceUsage.Staging,
                CpuAccessFlags.Read
            ));

            unsafe
            {
                var offsetX = (ScreenWidth - _captureWidth) / 2;
                var offsetY = (ScreenHeight - _captureHeight) / 2;
                var captureRegion = new CaptureRegion
                {
                    Offset = new Int2(offsetX, offsetY),
                    CaptureSize = new Int2(_captureWidth, _captureHeight)
                };

                captureRegionBuffer = device.CreateBuffer(
                    new BufferDescription(
                        Marshal.SizeOf<CaptureRegion>(),
                        BindFlags.ConstantBuffer,
                        ResourceUsage.Dynamic,
                        CpuAccessFlags.Write
                    ),
                    new SubresourceData(&captureRegion)
                );

                context.CSSetConstantBuffers(0, [captureRegionBuffer]);
                context.CSSetUnorderedAccessViews(0, [_outputUav]);
            }
        }

        public Memory<float>? CaptureFrame()
        {
            var result = _duplication.AcquireNextFrame(4, out _, out var resource);

            if (result.Failure) return default;

            if (result.Code == ResultCode.AccessLost)
            {
                _duplication.Release();
                _duplication = _output.DuplicateOutput(_d3D11Device);
                return default;
            }

            using var screenTexture = resource.QueryInterface<ID3D11Texture2D>();

            using var textureSrv = _d3D11Device.CreateShaderResourceView(screenTexture);
            _context.CSSetShaderResources(0, [textureSrv]);

            var dispatchX = (int)Math.Ceiling(_captureWidth / 4.0);
            var dispatchY = (int)Math.Ceiling(_captureHeight / 4.0);
            _context.Dispatch(dispatchX, dispatchY, 1);

            _context.CSSetShaderResources(0, []);

            _context.CopyResource(_stagingBuffer, _outputBuffer);

            var mappedResource = _context.Map(_stagingBuffer, 0, MapMode.Read);

            var backingArray = _backingArray.Value!;
            var output = new Memory<float>(backingArray);
            mappedResource.AsSpan<float>(_captureWidth * _captureHeight * 3).CopyTo(output.Span);
            _context.Unmap(_stagingBuffer, 0);

            resource.Dispose();
            _duplication.ReleaseFrame();

            return output;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct CaptureRegion
    {
        public Int2 Offset;
        public Int2 CaptureSize;
    }
}
</ScreenCapturer.cs>
<SigmoidSmoothing.cs>
namespace AimAssist;

public class SigmoidSmoothing(float steepness, float cap, float m, float n) : ISmoothingFunction
{
    public float Calculate(float distance)
    {
        return cap / (1f + m * (float)Math.Pow(n, steepness * Math.Sqrt(distance)));
    }
}
</SigmoidSmoothing.cs>
<ToggleActivationCondition.cs>
namespace AimAssist;

public class ToggleActivationCondition(ToggleActivationCondition.ToggleMouseButton toggleMouseButton)
    : IAimAssistCondition
{
    public enum ToggleMouseButton
    {
        Mouse4,
        Mouse5
    }


    private State _state = new(false, false);

    private bool IsDown => toggleMouseButton switch
    {
        ToggleMouseButton.Mouse4 => MouseMover.IsMouse4Down(),
        ToggleMouseButton.Mouse5 => MouseMover.IsMouse5Down(),
        _ => throw new ArgumentOutOfRangeException()
    };

    public bool ShouldAimAssist()
    {
        return _state.IsToggled;
    }

    public void Update()
    {
        if (IsDown && !_state.WasPreviouslyDown)
            _state.IsToggled = !_state.IsToggled;

        _state.WasPreviouslyDown = IsDown;
    }

    private record struct State(bool WasPreviouslyDown, bool IsToggled);
}
</ToggleActivationCondition.cs>
<YoloNASEngine.cs>
using System.Diagnostics;
using Microsoft.ML.OnnxRuntime;
using Microsoft.ML.OnnxRuntime.Tensors;

namespace AimAssist;

// ReSharper disable once InconsistentNaming
public sealed class YoloNASEngine : InferenceEngine
{
    public YoloNASEngine(string modelPath, SessionOptions sessionOptions) : base(modelPath, sessionOptions)
    {
        var inputMeta = Session.InputMetadata;
        Debug.Assert(inputMeta.Count == 1);
        Debug.Assert(inputMeta.First().Key == "input");
    }


    public override void Infer(Memory<float> input, int width, int height, float confidenceThreshold)
    {
        base.Infer(input, width, height, confidenceThreshold);
        var tensor = FromRgb32(input);

        var inputs = new List<NamedOnnxValue>
        {
            NamedOnnxValue.CreateFromTensor("input", tensor)
        };

        using var outputs = Session.Run(inputs);
        ParseOutput(outputs, confidenceThreshold);
    }


    private DenseTensor<byte> FromRgb32(Memory<float> input)
    {
        var tensor = new DenseTensor<byte>(new[] { 1, 3, InputHeight, InputWidth });

        Parallel.For(0, InputHeight, y =>
        {
            for (var x = 0; x < InputWidth; x++)
            {
                var index = y * InputWidth + x;
                var value = input.Span[index];
                tensor[0, 0, y, x] = (byte)(value * 255);
                tensor[0, 1, y, x] = (byte)(value * 255);
                tensor[0, 2, y, x] = (byte)(value * 255);
            }
        });

        return tensor;
    }


    private void ParseOutput(IDisposableReadOnlyCollection<DisposableNamedOnnxValue> output, float confidenceThreshold)
    {
        // Extract the number of predictions
        var numPredictions = (int)output.First(o => o.Name == "graph2_num_predictions")
            .AsTensor<long>().GetValue(0);

        // Extract bounding boxes
        var predBoxes = output.First(o => o.Name == "graph2_pred_boxes")
            .AsTensor<float>();

        // Extract scores
        var predScores = output.First(o => o.Name == "graph2_pred_scores")
            .AsTensor<float>();

        // Extract class IDs
        var predClasses = output.First(o => o.Name == "graph2_pred_classes")
            .AsTensor<long>();

        for (var i = 0; i < numPredictions; i++)
        {
            var confidence = predScores[0, i];
            if (confidence < confidenceThreshold) continue;

            var xMin = predBoxes[0, i, 0];
            var yMin = predBoxes[0, i, 1];
            var xMax = predBoxes[0, i, 2];
            var yMax = predBoxes[0, i, 3];

            DetectionsBuffer[i] = new DetectionResult
            {
                ClassId = predClasses[0, i],
                Confidence = confidence,
                XMin = xMin,
                YMin = yMin,
                XMax = xMax,
                YMax = yMax,
                Width = InputWidth,
                Height = InputHeight
            };
        }
    }
}
</YoloNASEngine.cs>
<YoloV8Engine.cs>
using System.Diagnostics;
using Microsoft.ML.OnnxRuntime;
using Microsoft.ML.OnnxRuntime.Tensors;

namespace AimAssist;

public sealed class YoloV8Engine : InferenceEngine
{
    private readonly int _maxClassIndex;
    private readonly int _modelFixedNumDetections;

    public YoloV8Engine(string modelPath, SessionOptions sessionOptions) : base(modelPath, sessionOptions)
    {
        var inputMeta = Session.InputMetadata;
        var outputMeta = Session.OutputMetadata;
        Debug.Assert(inputMeta.Count == 1);
        Debug.Assert(inputMeta.First().Key == "images");
        _maxClassIndex = outputMeta.First().Value.Dimensions[1];
        _modelFixedNumDetections = outputMeta.First().Value.Dimensions[2];
    }


    public override void Infer(Memory<float> input, int width, int height, float confidenceThreshold)
    {
        base.Infer(input, width, height, confidenceThreshold);
        var tensor = new DenseTensor<float>(input.ToArray(), [1, 3, InputHeight, InputWidth]);

        var inputs = new List<NamedOnnxValue>
        {
            NamedOnnxValue.CreateFromTensor("images", tensor)
        };

        using var outputs = Session.Run(inputs);
        ParseOutput(outputs, confidenceThreshold);
    }


    private void ParseOutput(IDisposableReadOnlyCollection<DisposableNamedOnnxValue> output, float confidenceThreshold)
    {
        var denseTensor = (output.First(o => o.Name == "output0").Value as DenseTensor<float>)!;
        var validIndices = Enumerable.Range(4 * _modelFixedNumDetections, 2 * _modelFixedNumDetections)
            .AsParallel().Select(
                (index) =>
                {
                    var classId = index / _modelFixedNumDetections - 4;
                    var detectionIndex = index % _modelFixedNumDetections;
                    if (denseTensor.GetValue(index) > confidenceThreshold)
                    {
                        return ((int, int)?)(detectionIndex, classId);
                    }
                    else
                    {
                        return null;
                    }
                }).Where((index) => index is not null).Select((index) => index!.Value).ToArray();

        var detectionCount = 0;
        foreach (var (j, classId) in validIndices)
        {
            var xCenter = denseTensor.GetValue(j);
            var yCenter = denseTensor.GetValue(j + _modelFixedNumDetections);
            var width = denseTensor.GetValue(j + 2 * _modelFixedNumDetections);
            var height = denseTensor.GetValue(j + 3 * _modelFixedNumDetections);
            var confidence = denseTensor.GetValue(j + (4 + classId) * _modelFixedNumDetections);

            DetectionsBuffer[detectionCount++] = new DetectionResult
            {
                ClassId = classId,
                Confidence = confidence,
                XMin = xCenter - width / 2,
                YMin = yCenter - height / 2,
                XMax = xCenter + width / 2,
                YMax = yCenter + height / 2,
                Width = InputWidth,
                Height = InputHeight
            };
        }
    }

    private static IEnumerable<int> SteppedIterator(int start, int end, int step)
    {
        for (var i = start; i < end; i += step)
        {
            yield return i;
        }
    }
}
</YoloV8Engine.cs>
